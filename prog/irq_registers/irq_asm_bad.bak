#define INT_STACK_ADDR 0x9000000

.globl irq_vec_asm
// TODO: Need to also save cpsr, maybe other state ?
irq_vec_asm:
    mov sp, #INT_STACK_ADDR
    sub lr, lr, #4              // Update the lr to where we should jump back to

    push {lr}                   // Save the PC when we got the interrupt
    sub sp, sp, #8              // make space for user-mode sp, lr
    push {r0-r12}               // Save the unbanked registers (NOTE: don't use
                                // FIQ mode!)

    mov r0, sp                  // save the location of where the saved state
                                // starts.

    mrs r1, spsr                // r1 = saved state
    mrs r2, cpsr                // r2 = current state
    bic r3, r2, #0x1f           // r3 = cpsr with no mode
    and r4, r1, #0x1f           // r4 = spsr mode bits
    orr r3, r4, r3              // r3 = cpsr with spsr mode
    msr cpsr, r2                // set the new mode (rmw)

    str r14, [r0, #52]          // store the sp
    str r13, [r0, #56]          // store the lr

    msr cpsr, r2                // reset the mode

    bl irq                      // call our actual irq handler

    mov r0, sp

    mrs r1, spsr                // r1 = saved state
    mrs r2, cpsr                // r2 = current state
    bic r3, r2, #0x1f           // r3 = cpsr with no mode
    and r4, r1, #0x1f           // r4 = spsr mode bits
    orr r3, r4, r3              // r3 = cpsr with spsr mode
    msr cpsr, r2                // set the new mode (rmw)

    ldr r14, [r0, #52]          // restore the sp
    ldr r13, [r0, #56]          // restore the lr

    msr cpsr, r2                // reset the mode
    ldm sp!,{r0-r15}^           // restore registers, jump back.
                                // including r15 also tells ldm to restore spsr
                                // into cpsr
